---
icon: codicon:symbol-misc
---

# Modules

> Shareable and reusable Nitro code.

Nitro modules are a way to **extends Nitro's runtime behavior** by accessing the Nitro context, hooking into Nitro lifecycle events, and adding new features.

> [!NOTE]
> This feature is still very new. A lot of things can be missing or broken. Please report any issues you find.

## Create a local module

Local modules are modules that are defined within the project. They are useful to extends the project's behavior without touching the main codebase or experimenting before creating a shareable module.

To create a local module, create a folder named `modules` at the root of the project and add a file into it. Name the file as you like, for example, `my-module.ts`.

Creating a module is as simple as exporting a object!

```ts [modules/my-module.ts]
import { NitroModule } from "nitropack";

export default <NitroModule>{};
```

> [!NOTE]
> It's possible to wrap the object with `defineNitroModule` function if you prefer but it's not required and doesn't change anything.

The core of a module is the `setup` function that received the Nitro context. This context can be used to add features and change Nitro's behavior.

```ts [modules/my-module.ts]
import { NitroModule } from "nitropack";

export default <NitroModule>{
  setup(nitro) {
      console.log("Hello from my module!");
  };
};
```

> [!TIP]
> The `setup` function can be async.

## Use a local module

Once the module is created, it can be used by importing it in the `nitro.config.ts` file. You can use both a relative path or an JS import.

::code-group
```ts [Relative Path]
export default defineNitroConfig({
  modules: ['./modules/my-module']
});
```

```ts [JS Import]
import myModule from "./modules/my-module";

export default defineNitroConfig({
  modules: [myModule]
});
```
::

## Use a packaged module

A packaged module is a module that is published on a registry like npm and that can be installed in any Nitro project.

The good part is that the usage of a packaged module is the same as a local module. Just import it in the `nitro.config.ts` file using the module name or a JS import.

::code-group
```ts [Module Name]
export default defineNitroConfig({
  modules: ['nitro-cloudflare-dev']
});
```

```ts [JS Import]
import cloudflareDev from "@nitro-cloudflare-dev";

export default defineNitroConfig({
  modules: [cloudflareDev]
});
```
::

Easy!

> [!NOTE]
> For the moment, we does not provide templates or starter to create a module.

## Deep dive into modules

Before diving into the details and examples, let's see our recommended architecture for modules.

::code-group
```plaintext [Local Module]
modules/
  my-module/
    index.ts (entry point)
    runtimes/
      routes/
      api/
      middleware/
```

```plaintext [Packaged Module]
src/
  module.ts (entry point)
  runtimes/
    routes/
    api/
    middleware/
```
::

You're globally free to organize the runtime folders as you want since there is no [auto imports](/guide/utils#auto-imports). **Everything must be manually imported**. Keeping the same as a Nitro project can help to understand and maintain the module.

> [!NOTE]
> Adding features does not provide the best DX for now. We are working on adding utilities and helpers to make it easier.

### Create the path resolver

The path resolver is a function that resolves the path of a module runtime file. It's used to import the runtime files in the module ant to do it correctly when the module is used in another project.

```ts [modules/my-module/index.ts]
import { NitroModule } from "nitropack";
import { fileURLToPath } from "node:url";

export default <NitroModule>{
  setup() {
    const resolve = (path: string) =>
      fileURLToPath(new URL(path, import.meta.url));
  }
}
```

**Every relative path**  path must be resolved using this function.

### Add a route

In the runtime folder, create a `routes` folder and add a file named `hello.ts`.

> [!NOTE]
> The file name is not important. A module does not rely on auto import.

```ts [modules/my-module/runtimes/routes/hello.ts]
import { defineEventHandler } from "#imports";

export default defineEventHandler(() => {
  return "hello";
});
```

Note the import from `#imports`. In a module, you must import everything you use manually to avoid breaking the module when used in another project.

Then, the route can be used in the module:

```ts [modules/my-module/index.ts]
import { NitroModule } from "nitropack";
import { fileURLToPath } from "node:url";

export default <NitroModule>{
  setup(nitro) {
    const resolve = (path: string) =>
      fileURLToPath(new URL(path, import.meta.url));

    nitro.options.handlers ||= [];
    nitro.options.handlers.push({
      route: "/", // Choose the route you want
      handler: resolve("runtimes/routes/hello.ts"),
      method: 'get'
    });
  },
};
```

:read-more{to="/guide/routing#event-handlers"}

You can add params to the route using the [Radix3 syntax](https://radix3.unjs.io).

> [!NOTE]
> Radix3 is the router under H3. The filesystem routing automatically convert the file name to a Radix3 path.

```ts
import { NitroModule } from "nitropack";
import { fileURLToPath } from "node:url";

export default <NitroModule>{
  setup(nitro) {
    const resolve = (path: string) =>
      fileURLToPath(new URL(path, import.meta.url));

    nitro.options.handlers ||= [];
    nitro.options.handlers.push({
      route: "/:name",
      handler: resolve("runtimes/routes/hello.ts"),
    });
  },
};
```

The param `name` will be available in the event handler using the utility `getRouterParam` or `getRouterParams`.

:read-more{to="/guide/utils#h3-utils"}

### Add a middleware

In the runtime folder, create a `middleware` folder and add a file named `logger.ts`.

```ts [modules/my-module/runtimes/middleware/logger.ts]
import { defineEventHandler } from "#imports";

export default defineEventHandler(() => {
  console.log("request logged");
});
```

Then, the middleware can be used in the module:

```ts [modules/my-module/index.ts]
import { NitroModule } from "nitropack";
import { fileURLToPath } from "node:url";

export default <NitroModule>{
  setup(nitro) {
    const resolve = (path: string) =>
      fileURLToPath(new URL(path, import.meta.url));

    nitro.options.handlers ||= [];
    nitro.options.handlers.push({
      middleware: true,
      handler: resolve("runtimes/middleware/logger.ts"),
    });
  },
};
```

:read-more{to="/guide/routing#middleware"}

### Add a plugin

In the runtime folder, create a `plugins` folder and add a file named `analytics.ts`.

```ts [modules/my-module/runtimes/plugins/analytics.ts]
import { defineNitroPlugin } from "#imports";

export default defineNitroPlugin((nitroApp) => {
  nitroApp.hooks.hook("beforeResponse", (_, response) => {
    response.body += '<script>console.log("analytics")</script>';
  });
});
```

Then, the plugin can be used in the module:

```ts [modules/my-module/index.ts]
import { NitroModule } from "nitropack";
import { fileURLToPath } from "node:url";

export default <NitroModule>{
  setup(nitro) {
    const resolve = (path: string) =>
      fileURLToPath(new URL(path, import.meta.url));

    nitro.options.plugins ||= [];
    nitro.options.plugins.push(resolve("runtimes/plugins/analytics.ts"));
  },
};
```

Now, every response will have the analytics script injected!

:read-more{to="/guide/plugins"}

## And more...

With a module, you can do everything you can do in a Nitro project like adding a storage, a task, a websocket handler, a runtime config, etc.
